{-# LANGUAGE PackageImports #-}
module Main(main) where

import Data.Char (toUpper,isAlphaNum)
import Data.List (partition,nub)
import qualified Data.Map as Map
import System.Environment
import System.IO
import System.Exit
import System.Console.GetOpt
import System.FilePath ((</>))
import Text.PrettyPrint

import AST
import CTypes
import Decode
import Encode
import Common
import Parse
import Pretty

import "language-c" Language.C (parseCFile)
import "language-c" Language.C.System.GCC (newGCC)

data Options = Options
  { inputFile  :: FilePath
  , includeDir :: FilePath      -- empty, if not specified
  , outFiles   :: [(File, FilePath)]
  }

data Operation = Encode | Decode | Pretty
                 deriving (Show,Eq,Ord,Enum)

data File      = TypesHeader | Header Operation | Impl Operation
                 deriving (Show,Eq,Ord)

options :: [OptDescr (Options -> Options)]
options = [Option [] ["eh"] (OptArg (outFileMb $ Header Encode) "FILE")
             "Encode header file name"
          ,Option [] ["dh"] (OptArg (outFileMb $ Header Decode) "FILE")
             "Decode header file name"
          ,Option [] ["ph"] (OptArg (outFileMb $ Header Pretty) "FILE")
             "Pretty header file name"
          ,Option [] ["ei"] (ReqArg (outFile $ Impl Encode) "FILE")
             "Encode implementation file name"
          ,Option [] ["di"] (ReqArg (outFile $ Impl Decode) "FILE")
             "Decode implementation file name"
          ,Option [] ["pi"] (ReqArg (outFile $ Impl Pretty) "FILE")
             "Pretty implementation file name"
          ,Option ['i'] [] (ReqArg (\x o -> o { includeDir = x }) "DIR")
             "Include directory (headers are saved in here)"
          ]
  where outFile f x o = o { outFiles = (f,x) : outFiles o }
        outFileMb f (Just x) o = outFile f x o
        outFileMb _ Nothing o  = o


getOptions :: IO Options
getOptions =
  do args <- getArgs
     case getOpt Permute options args of
       (fs, [f1,f2], []) -> return $ foldl (\x f -> f x) o fs
          where hs = TypesHeader : map Header [Encode .. ]
                o  = Options { inputFile = f1
                             , includeDir = ""
                             , outFiles = [(h,f2)| h <- hs ]
                             -- use the same header for everything, by default.
                             }
       (_, xs, []) -> do hPutStrLn stderr "Parameters:"
                         mapM_ (hPutStrLn stderr) xs
                         usage
       (_,_,errs) -> mapM_ (hPutStrLn stderr) errs >> usage

usage :: IO a
usage = do hPutStrLn stderr
             $ usageInfo "prog [flags] INPUTFILE TYPESHEADER" options
           exitFailure

parseSpec :: FilePath -> IO Spec
parseSpec name =
  do res <- parseCFile (newGCC "gcc") Nothing ["-nostdinc"] name
     case res of
       Left e -> hPutStrLn stderr (show e) >> exitFailure
       Right t -> case toSpec t of
                    Left e  -> hPutStrLn stderr e >> exitFailure
                    Right x -> return x


main :: IO ()
main = do
  opts <- getOptions
  spec <- parseSpec (inputFile opts)

  saveFiles opts ( generateTypesHeader spec
                 : [ f | (Impl op,_) <- outFiles opts
                       , f <- generateImpl op opts spec
                   ]
                 )

doLookupFile :: File -> Options -> FilePath
doLookupFile f opts =
  case lookup f (outFiles opts) of
    Nothing -> error ("Unexpectedly missing file: " ++ show f)
    Just o  -> o

autoGenWarning :: Doc
autoGenWarning =
  vcat [ text "// WARNING: This file is automatically generated."
       , text "// Please do not edit it because your changes might get lost."
       ]

includeGuard :: FilePath -> Doc -> Doc
includeGuard file doc =
  vcat [ text "#ifndef" <+> ident
       , text "#define" <+> ident
       , doc
       , text "#endif"
       ]
  where
  ident = text (map cvt file)

  cvt a | isAlphaNum a = toUpper a
  cvt _                = '_'

type FileContent = (File, [String], Doc)  -- (role, includes, code)

generateTypesHeader :: Spec -> FileContent
generateTypesHeader spec =
  (TypesHeader, [], vcat $ map (text . showP . cDecl) $ order $ typeDecls spec)

generateImpl :: Operation -> Options -> Spec -> [FileContent]
generateImpl h opts spec =
  [ ( Header h
    , ("<" ++ doLookupFile TypesHeader opts ++ ">") : h_incs
    , vcat header
    )
  , ( Impl h
    , ("<" ++ doLookupFile (Header h) opts ++ ">") : c_incs
    , vcat impl
    )
  ]
  where
  (h_incs, header, c_incs, impl) =
     case h of
       Encode ->
         ( ["<stdlib.h>"]
         , hdrs
         , [ "<stdint.h>", "<string.h>" ]
         , helpers : imps
         )
         where (helpers,env) = helperFuns Encode.helper spec
               (hdrs,imps)   = unzip (map (encodeFun env) (codecs spec))

       Decode ->
         ( ["<stdlib.h>"]
         , hdrs
         , [ "<stdint.h>", "<string.h>" ]
         , helpers : imps
         )
         where (helpers,env) = helperFuns Decode.helper spec
               (hdrs,imps)   = unzip (map (decodeFun env) (codecs spec))

       Pretty ->
         ( []
         , map (text . showP) hdrs
         , [ "<stdio.h>" ]
         , map (text . showP) $ snd indentFunction : imps
         )
         where ds          = typeDecls spec
               (hdrs,imps) = unzip (map (prettyFun ds) ds)


{- This functions computes the content of the various files.
Note that we allow the code for multiple operations to be saved in the same
files---the code is simply concatenated together, so we should make sure that
there are no name clashes. -}

saveFiles :: Options -> [FileContent] -> IO ()
saveFiles opts = saveAll . foldr insertCode (Map.empty, Map.empty)
  where
  insertCode (f,inc,d) (hs,cs) =
    let file             = doLookupFile f opts
        jn (is,a) (js,b) = (is ++ js, a $$ b)
        upd              = Map.insertWith jn file (inc,d)
    in if isHeader f then (upd hs, cs) else (hs, upd cs)

  isHeader (Impl _)     = False
  isHeader _            = True

  finalize (is,c)       = autoGenWarning
                       $$ vcat [ text "#include" <+> text u | u <- nub is ]
                       $$ c

  saveHeader (f,d)      = writeFile (includeDir opts </> f)
                                    $ show $ includeGuard f
                                    $ (noUnusedWarns $$ finalize d)

  saveImpl   (f,d)      = writeFile f $ show $ finalize d


  saveAll (hs,cs)       = do mapM_ saveHeader (Map.toList hs)
                             mapM_ saveImpl   (Map.toList cs)

noUnusedWarns :: Doc
noUnusedWarns = vcat $ map text
  [ "#pragma GCC diagnostic ignored \"-Wunused-function\""
  , "#pragma GCC diagnostic ignored \"-Wunused-variable\""
  ]
--------------------------------------------------------------------------------

uses :: Type -> [Ident]
uses ty =
  case ty of
    Pointer t   -> uses t
    Reference t -> uses t
    Array t _   -> uses t
    Struct fs   -> concatMap (uses . fType) fs
    Union _ fs  -> concatMap (uses . fType) fs
    PrimType _  -> []
    Named x     -> [x]
    String      -> []

order :: [Decl] -> [Decl]
order = ox []
  where
  ox _ []  = []
  ox ok ds = let (as,bs) = partition (all (`elem` ok) . uses . dType) ds
             in as ++ ox (map dName as ++ ok) bs
